use std::{fs, path::Path};

use clap::CommandFactory;
use once_cell::sync::Lazy;
use regex::Regex;
use snafu::{ResultExt, Snafu};
use stackablectl::cli::Cli;

const COMMANDS: &[&str] = &[
    "completions",
    "stacklets",
    "operator",
    "release",
    "stack",
    "cache",
    "demo",
    ".",
];

static CODE_LISTING_PATTERN: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)// Autogenerated by cargo xtask gen-docs\. DO NOT CHANGE MANUALLY!\n\[source,console\]\n----\n\$ stackablectl.*\n").unwrap()
});
const DOCS_BASE_PATH: &str = "docs/modules/stackablectl/pages/commands";
const USAGE_END_STRING: &str = "\n----";

#[derive(Debug, Snafu)]
pub enum GenDocsError {
    #[snafu(display("No such subcommand: {name}"))]
    NoSuchSubcommand { name: String },

    #[snafu(display("io error"))]
    Io { source: std::io::Error },
}

pub fn generate() -> Result<(), GenDocsError> {
    let mut cli = Cli::command();

    for command_page_name in COMMANDS {
        let usage_text = if command_page_name == &"." {
            cli.render_long_help().to_string()
        } else {
            match cli.find_subcommand_mut(command_page_name) {
                Some(cmd) => cmd.render_long_help().to_string(),
                None => {
                    return Err(NoSuchSubcommandSnafu {
                        name: command_page_name.to_string(),
                    }
                    .build())
                }
            }
        };

        // Needed to remove trailing whitespaces in empty lines
        let usage_text: Vec<_> = usage_text.lines().map(|l| l.trim_end()).collect();
        let usage_text = usage_text.join("\n");

        let page_path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .and_then(Path::parent)
            .unwrap()
            .join(DOCS_BASE_PATH)
            .join(format!(
                "{}.adoc",
                if command_page_name == &"." {
                    "index"
                } else {
                    command_page_name
                }
            ));

        let mut doc_page = fs::read_to_string(&page_path).context(IoSnafu)?;

        let m = CODE_LISTING_PATTERN.find(&doc_page).unwrap();
        let usage_start = m.end();
        let usage_end = doc_page[usage_start..].find(USAGE_END_STRING).unwrap();

        doc_page.replace_range(
            usage_start..usage_start + usage_end,
            usage_text.to_string().trim(),
        );
        fs::write(page_path, doc_page).context(IoSnafu)?;
    }

    Ok(())
}
